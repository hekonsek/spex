# Separate command-line logic from core/domain/business logic

## Context

Many Node-based CLI tools (especially those scaffolded or generated by AI tools) mix CLI parsing logic (Commander.js, Yargs, oclif, etc.) with the core/domain/business logic. This makes the codebase hard to understand and test, couples the domain to a specific CLI framework, and complicates reuse (e.g., using the same logic from HTTP APIs, background jobs, or other CLIs).

## Decision

We will strictly separate CLI parsing from core/domain/business logic:

- `src/cli/cli.ts` (or equivalent entrypoint) will contain only:
  - CLI setup and argument parsing (Commander.js, Yargs, oclif, etc.).
  - Wiring of parsed arguments to core/domain/business services.
  - CLI libraries like Commander.js must be referenced only from the entrypoint (`cli/cli.ts`), not from core/domain modules.
- core/domain/business logic will live in `src/core` directory in dedicated modules/packages that:
  - Expose clear classes, functions, or use-cases.
  - Have no dependency on CLI libraries.

## Consequences

Pros:
- ✅ **Readability**: It is much easier to understand CLI parsing and core logic.
- ✅ **Testability**: Core logic can be unit-tested without bootstrapping a CLI or mocking `process.argv`.
- ✅ **Reusability**: The same logic can be called from other interfaces (HTTP, queues, other CLIs).
- ✅ **Replaceable CLI framework**: We can switch from Commander.js to another library with minimal changes (mostly in `cli.ts`).
- ✅ **Cleaner architecture**: Clear separation of concerns and easier onboarding for new contributors.

Cons:
- ❌ Slightly more initial boilerplate (wiring code in `cli.ts` to domain modules).
- ❌ Requires discipline and code reviews to prevent CLI-related logic from leaking into domain code.

## Alternatives considered

- **Keep CLI and business logic mixed in one file**. Simpler initial setup, but leads to tightly coupled, hard-to-test, and hard-to-evolve codebases.