# Terminal session script instructions

## Accessing logs from local filesystem 

- If you can access `~/.cache/script` directory, it means that you can access terminal script session logs even without calling MCP server. Take advanatage of this fact and read these logs when needed.
- You can also rely on Linux file timestamps to see when file was updated.

## Accessing logs without access to local filesystem

- If you can access `~/.cache/script` directory, you can should this MCP server to read logs resources.

## Logs format

- Terminal session script logs are generated using standard Linux `script` command.
- Terminal session script logs are named with timestamp indicating when session started.

## How to make use of terminal session script logs

- When you are asked about some problem related to cli, check for recently updated terminal session scripts and see if you can see activities related to this topic.
- Check primarily in the recent logs.

## Examples

When you are working on Python application and user is complaining that something is not working, look for the latest sessions logs to see if there is soemthing related to the complaint.

When you are working on Terraform and user is complaining that something is not working, check recent sessions logs to see if he/she tried to applied Terraform files you're currently working on. 

# Use Commander as library for Node-based command-line tools

## Context

We are building Node-based command-line tools and need a standard library for parsing arguments, defining commands/subcommands, and generating help output. The library should be mature, well-documented, and widely adopted in the Node ecosystem.

## Decision

We will use [commander.js](https://github.com/tj/commander.js) as the default CLI library for all new Node-based command-line tools in this project.

Commander is currently the most popular library for Node-based CLIs and offers a simple, declarative API for defining commands, options, and help text.

## Consequences

Pros:
* ✅ Consistent CLI style and behavior across all tools.
* ✅ Faster development thanks to Commander’s concise API and good documentation.
* ✅ Easier onboarding for new contributors familiar with Commander.

Cons:
* ❌ Tight coupling to Commander’s API; switching to another library later will require refactoring.
* ❌ We inherit Commander’s limitations and release cycle.

## Alternatives considered

- **yargs**. Powerful and mature, but the configuration style is more verbose and less intuitive. Much less popular than Commander.
- **oclif**. Very capable framework, but heavier-weight and better suited for large CLIs with plugins; overkill for our current needs. Much less popular than Commander.
- **util.parseArgs**. No support for subcommands and help docs messages. Only basic arguments/flags parsing. It is always better to start with Commander.js even for simple applications - Commander is super simple but scales as application gets more complicated. 
- **Custom argument parsing**. Maximum flexibility, but would require more effort to implement and maintain, with no clear benefit over a dedicated library.


# Separate command-line logic from core/domain/business logic

## Context

Many Node-based CLI tools (especially those scaffolded or generated by AI tools) mix CLI parsing logic (Commander.js, Yargs, oclif, etc.) with the core/domain/business logic. This makes the codebase hard to understand and test, couples the domain to a specific CLI framework, and complicates reuse (e.g., using the same logic from HTTP APIs, background jobs, or other CLIs).

## Decision

We will strictly separate CLI parsing from core/domain/business logic:

- `src/cli/cli.ts` (or equivalent entrypoint) will contain only:
  - CLI setup and argument parsing (Commander.js, Yargs, oclif, etc.).
  - Wiring of parsed arguments to core/domain/business services.
  - CLI libraries like Commander.js must be referenced only from the entrypoint (`cli/cli.ts`), not from core/domain modules.
- core/domain/business logic will live in `src/core` directory in dedicated modules/packages that:
  - Expose clear classes, functions, or use-cases.
  - Have no dependency on CLI libraries.

## Consequences

Pros:
- ✅ **Readability**: It is much easier to understand CLI parsing and core logic.
- ✅ **Testability**: Core logic can be unit-tested without bootstrapping a CLI or mocking `process.argv`.
- ✅ **Reusability**: The same logic can be called from other interfaces (HTTP, queues, other CLIs).
- ✅ **Replaceable CLI framework**: We can switch from Commander.js to another library with minimal changes (mostly in `cli.ts`).
- ✅ **Cleaner architecture**: Clear separation of concerns and easier onboarding for new contributors.

Cons:
- ❌ Slightly more initial boilerplate (wiring code in `cli.ts` to domain modules).
- ❌ Requires discipline and code reviews to prevent CLI-related logic from leaking into domain code.

## Alternatives considered

- **Keep CLI and business logic mixed in one file**. Simpler initial setup, but leads to tightly coupled, hard-to-test, and hard-to-evolve codebases.

# CLI should listen to events from core logic via listeners

## Context

We are building a Node.js + TypeScript CLI application with the following requirements:

- Clear separation between:
  - **Core/business logic** (pure, reusable, testable)
  - **CLI layer** (argument parsing, stdout/stderr, UX, exit codes)
- The core must not:
  - print to stdout/stderr
  - detect TTY
  - depend on CLI/UI libraries
- The CLI may support:
  - progress updates
  - informational messages
  - warnings and errors
  - optional JSON / quiet / CI-safe output

The core needs a mechanism to communicate **what is happening** without deciding **how it is rendered**.

## Decision

Introduce a **Listener** port interface in the core module, then implement listener in CLI to react to events (for example to print output). 

- Core logic:
  - uses listener interface reference to generate events
  - returns structured results or throws typed errors
- CLI:
  - provides concrete given `Listener` callback implementation during core logic invocation
  - callback renders events to stdout/stderr (text, progress bars, JSON, etc.)
  - owns all printing and exit-code decisions

This follows Ports & Adapters (Hexagonal Architecture) principles.

### Example

```ts
// core/example.ts

export interface ExampleServiceListener {
  onGreeting(greeting: string): void;
}

export class ExampleService {
  constructor(private readonly listener: ExampleServiceListener) {}

  helloWorld(name: string): void {
    // Some core domain logic here
    const greeting = `Hello ${name}!`;

    // Emit event
    this.listener.onGreeting(greeting);
  }
}

```

Usage in CLI:

```ts
// cli/cli.ts
import { ExampleService } from "../core/example";

const service = new ExampleService({
  onGreeting(greeting: string): void {
    console.log(greeting);
  },
});
service.helloWorld("Henry");

```

## Consequences

Positive:

* Strong separation of concerns
* Core is reusable and side-effect free
* CLI UX can evolve independently
* Deterministic, testable behavior
* Easy support for `--json`, `--quiet`, CI mode

Negative / Trade-offs:

* Additional boilerplate (interfaces, adapters)
* Event contract must be versioned carefully
* Overuse of events can cause noisy output
* Event ordering must be considered for parallel execution

## Alternatives considered

**Core returns `{ result, messages[] }`**:
- Simple but no streaming progress
- Accumulates output in memory

**Async iterator / Observable of events**:
- Powerful for streaming workflows
- More complex lifecycle and API

**Logging framework inside core**:
- Familiar tooling
- Leaks transport/formatting concerns into core


# Use chalk for coloring output

## Context

CLI tools should provide output that is easy to scan quickly. Color helps distinguish
success, warnings, errors, and informational messages, especially during long-running
tasks.

Without a standard coloring approach, projects tend to:

- mix raw ANSI escape codes with plain text
- apply inconsistent styles between commands
- break output readability in non-TTY environments (CI logs, redirected output)
- make it harder to keep output accessible and maintainable

We need one default library for colorized CLI output that is simple, stable, and widely
used in Node.js ecosystems.

## Decision

We will use [`chalk`](https://github.com/chalk/chalk) as the default library for
coloring terminal output in Node-based CLI tools.

Rules:

- Color formatting is allowed only in CLI/presentation layer modules.
- Core/domain logic must return structured results or typed events without color/ANSI
  formatting.
- Color must enhance text, not replace meaning (for example, keep explicit labels like
  `ERROR`, `WARN`, `OK`).
- Output must remain readable when color is disabled (non-TTY, `NO_COLOR`, CI logs).

## Consequences

Pros:
* ✅ Consistent and readable output across commands.
* ✅ Better user experience for interactive CLI usage.
* ✅ Cleaner code than manual ANSI escape sequences.
* ✅ Centralized styling conventions (severity colors, emphasis, dimmed metadata).
* ✅ Easier maintenance and onboarding.

Cons:
* ❌ Adds dependency on a third-party package.
* ❌ Potential style overuse can reduce readability if not reviewed.
* ❌ Color behavior can vary between terminals and operating systems.

## Alternatives considered

- **Manual ANSI escape codes**. No dependency, but difficult to read/maintain and easy to
  misuse.
- **picocolors / colorette / kleur**. Smaller libraries with similar goals, but we choose
  Chalk for broad adoption and familiar API.
- **No color at all**. Simplest output, but lower scanability and poorer UX for human
  operators.


# Use Ora as progress indicator

## Context

Many CLI commands include network calls, file I/O, or other long-running operations.
Without progress feedback, users cannot tell whether the command is still running,
stuck, or failed.

Raw log lines can provide status, but they are often noisy and reduce readability during
interactive use. We need a standard way to show concise in-place progress for humans
while preserving machine-readable output modes.

## Decision

We will use [`ora`](https://github.com/sindresorhus/ora) as the default progress
indicator (spinner/status line) for interactive CLI execution.

Rules:

- Ora usage is limited to CLI/presentation layer modules.
- Core/domain logic must emit typed events or structured results, not spinner calls.
- Spinner output must be disabled for non-interactive contexts (`!isTTY`, CI,
  `--json`, `--quiet`).
- Commands must still provide clear final status messages when spinner is disabled.

## Consequences

Pros:
* ✅ Better perceived responsiveness for long-running commands.
* ✅ Cleaner terminal UX than repeated status log lines.
* ✅ Consistent progress behavior across commands.
* ✅ Easy mapping from domain events to CLI feedback.

Cons:
* ❌ Adds a third-party runtime dependency.
* ❌ Spinner behavior can differ across terminals/platforms.
* ❌ Requires careful fallback handling for CI/log capture/non-TTY modes.

## Alternatives considered

- **No progress indicator**. Simplest implementation, but weak UX for slow commands.
- **Manual carriage-return updates (`\\r`)**. No dependency, but error-prone and less
  consistent.
- **Other spinner/progress libraries** (for example `cli-spinners`, `listr2`). Viable,
  but Ora offers a minimal API and broad adoption for standard single-task spinner use.


# Bootstrap new CLI with a single `version` command

## Context

When starting a new CLI project, it is tempting to scaffold many commands before the
project has stable requirements. This usually introduces noise, increases maintenance
cost, and leads to early design decisions that are hard to change.

We need a minimal, consistent bootstrap baseline that:

- proves the CLI entrypoint and command wiring work
- provides immediate user value
- avoids premature command surface expansion

## Decision

For newly bootstrapped CLI projects, we will initially add only one command:
`version`.

Behavior:

- `version` prints the current project version
- the version is read from `package.json` (`version` field)
- no additional business/domain commands are added at bootstrap stage

Additional commands are introduced only after concrete use-cases are defined.

## Consequences

Pros:
* ✅ Smaller initial codebase and faster project setup.
* ✅ Lower risk of adding placeholder commands that later need removal/refactoring.
* ✅ Immediate sanity check that the CLI binary, packaging, and release versioning are wired correctly.
* ✅ Clear and consistent bootstrap pattern across projects.

Cons:
* ❌ Very limited functionality in the first project iteration.
* ❌ Teams may need an extra step to add first domain command after bootstrap.
* ❌ Some scaffolding tools may expect a default command set and require adjustment.

## Alternatives considered

- **Scaffold multiple starter commands** (e.g. `init`, `help`, `status`). Faster demo surface, but encourages premature API design and unused code.
- **Expose only `--version` flag without `version` command**. Simpler in some frameworks, but less explicit than a dedicated command and less aligned with command-based CLI workflows.


# ADR: Use execFile Instead of exec (and shell-enabled spawn) to Prevent Shell Injection

## Context

Our Node.js CLI application occasionally needs to invoke external programs (e.g., `git`, `docker`, `kubectl`, `terraform`, or internal binaries). This introduces a high-risk boundary: **untrusted input** from CLI arguments, environment variables, config files, or upstream automation may influence the executed command.

In Node.js, there are multiple ways to execute OS commands:

- `child_process.exec(commandString)` (shell)
- `child_process.spawn(command, args)` (no shell by default, but can enable shell)
- `child_process.execFile(file, args)` (no shell)

Shell-based execution (`exec`, or `spawn(..., { shell: true })`, or `spawn("sh", ["-c", "..."])`) is vulnerable to **shell injection** if untrusted input is interpolated into the command string. This is particularly dangerous for CLIs because they often run with elevated developer/CI permissions and can access sensitive files, credentials, and networks.

We want a default approach that is safe, consistent, and cross-platform.

## Decision

We will **use `child_process.execFile()` as the default mechanism** for invoking external programs from our CLI.

We will avoid using `child_process.exec()` in production code.

We will also avoid using `spawn()` with a shell (`{ shell: true }`) or any pattern that reintroduces shell parsing (e.g., `spawn("sh", ["-c", "..."])`, `spawn("cmd.exe", ["/c", "..."])`) unless an explicit exception is approved and documented.

Rationale behind using `execFile`:

- `execFile` does **not invoke a shell** by default, so shell metacharacters (`;`, `&&`, `|`, `$()`, backticks) are not interpreted.
- Arguments are passed as an array, avoiding unsafe string interpolation.
- Cross-platform behavior is more predictable than shell quoting/escaping.
- Centralizing command execution behind a safe default reduces review burden and prevents recurring vulnerabilities.

## Consequences

**Positive**:
- Strong mitigation against shell injection vulnerabilities.
- More predictable behavior across OSes (Linux/macOS/Windows).
- Encourages better separation of “command + args” and reduces accidental interpolation.
- Easier auditing: grep for `exec(` becomes a strong signal.

**Negative / Trade-offs**:
- Some shell features (pipes, redirects, globbing, command chaining) are not available directly.
  - We must implement these via Node APIs, explicit multiple process calls, or well-reviewed exceptions.
- `execFile` buffers stdout/stderr by default (like `exec`). For very large output, we may need `spawn` streaming.
- Requires more explicit handling for environment, cwd, and error reporting.

## Alternatives Considered

1. **Use `exec()` with escaping/sanitization**
   - Rejected: shell escaping is error-prone, varies by shell and platform, and easy to bypass.
2. **Use `spawn()` everywhere**
   - Not chosen as default: while safe without shell, it’s easier to accidentally enable `shell: true`, and the API encourages streaming patterns that may complicate simple use cases. We still allow `spawn` for streaming when needed.
3. **Use a third-party wrapper (e.g., execa)**
   - Possible future enhancement: wrappers can improve ergonomics (promises, better error objects). Still must enforce “no shell” and argument arrays. Not required for the ADR’s core goal.
